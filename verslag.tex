\documentclass[a4paper,11pt]{report}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{lmodern}

\title{Compiler Construction}
\author{Sander in 't Veld \and Joran van Apeldoorn}

\begin{document}

\maketitle
\tableofcontents

%\begin{abstract}
%\end{abstract}

\chapter{Abstract Syntax Tree}

\chapter{Compiler Phases}
The first three phases interpret the code and build the full abstract syntax tree. The next three phases restructure, optimise and prepare the AST, before the last phase generates the assembly instructions.

\section{Loading the code}
\subsection{Running the preprocessor}
Our compiler runs the \texttt{CPP} preprocessor and saves the resulting code in a hidden file called `\texttt{dir/.code.cvc.cpp}', if the original code was called `\texttt{dir/code.cvc}'. This step removes single- and multi-line comments, while retaining line and column numbers. It also links header files. The flag \texttt{-I path} can be used to search for header files in the directory \texttt{path}.

The resulting code is used as input for the next phase.

\subsection{Scanning and Parsing}
Our scanner interprets the \texttt{\#line} preprocessor hints to provide accurate error messages during scanning and parsing.

The scanner accepts \texttt{CR}, \texttt{LF}, \texttt{CR LF} and \texttt{LF CR} as a valid line ending.

Integers between $-2^{31}$ and $2^{31}-1$ (inclusive) are always supported; larger integers may be supported, depending on the platform. Floats have similar ranges of support. The scanner accepts both \texttt{.5} and \texttt{2.} as shorthand notation for \texttt{0.5} and \texttt{2.0} respectively.

The parser follows the associativity and precedence of operators as described by the C standard.

\section{Context Analysis}
In our compiler, the code is analysed just as it is written: from top to bottom, from left to right. In this light, a piece of code such as
\begin{verbatim}
int a = b;
int b = 2;
\end{verbatim}
will be interpreted as ``\emph{declare} \texttt{a}, \emph{assign} \texttt{b} \emph{to} \texttt{a}, \emph{declare} \texttt{b}, \emph{assign} $2$ \emph{to} \texttt{b}'', and thus results in a namelinking error. Similarly, when namelinking a piece of code such as
\begin{verbatim}
int a = 2;
int foo()
{
  int a = a;
  return a;
}
\end{verbatim}
the declaration of the local variable \texttt{a} overshadows the global variable \texttt{a}, \emph{before} the call \texttt{a} is linked to the last declaration (that is, to the local variable); the resulting program will have unspecified behaviour, and a call to \texttt{foo()} will most likely not return $2$.

An exception to this rule is the global scope. First, the global functions are stored, then the global variables are linked from top to bottom, from left to right. After this, namelinking enters the bodies of the global function definitions. A functions body is always entered \emph{after} everything else on the current scope level is namelinked.

The iterators of \texttt{for}-loops are also linked in this phase. Iterators are considered to be part of the \texttt{for}-loop's subscope, and thus are namelinked \emph{after} the \emph{from}, \emph{to} and \emph{incr} fields of the loop. Nested \texttt{for}-loops may have the same iterator name, with each new iterator shadowing calls to previous iterators.

\section{Type Checking}
\subsection{Type Inference}
\subsection{Type Matching}

\section{Code Restructuring}
\subsection{Iterator Splitting}
In this phase, iterators are moved to the back of the local variable list.

\subsection{Array Splitting}
\subsubsection{Array Literal Unfolding}
Array literals must be homogenous. Mixed array literal and array constant notation, such as
\begin{verbatim}
int[2, 2] a = [1, [3, 4]];
\end{verbatim}
is not allowed. Having been matched to their proper dimensions during type checking, they are now unfolded recursively, where a piece of code such as
\begin{verbatim}
a = [[5, 6], [7, 8]];
\end{verbatim}
first becomes
\begin{verbatim}
a[0] = [5, 6];
a[1] = [7, 8];
\end{verbatim}
before finishing at
\begin{verbatim}
a[0, 0] = 5;
a[0, 1] = 6;
a[1, 0] = 7;
a[1, 1] = 8;
\end{verbatim}
Note that the intermediate stages are not valid code, but this is of no significance, since the phase never stops until it is finished.
\subsection{Getters and Setters}
Creating getters and setters out of global variables happens in three phases. First, a getter and setter is created for each exported global variable and each external global variable. Then, calls to external variables become calls to getters, and assignments to them become setter-statements. Finally, the external global variables are removed from the AST, as they have been fully replaced. Exported variables are not removed, as they are still used locally.
\subsection{Ternary Operators}
Short circuit binary operators are replaced by Hoare's conditionals: \texttt{a \&\& b} becomes \texttt{b} $\triangleleft$ \texttt{a} $\triangleright$ \texttt{false}, and \texttt{a || b} becomes \texttt{true} $\triangleleft$ \texttt{a} $\triangleright$ \texttt{b}.

Casts from bools to ints and floats also become Hoare's conditionals: \texttt{(int) b} becomes $1~\triangleleft$ \texttt{b} $\triangleright~0$, and \texttt{(float) b} becomes $1.0~\triangleleft$ \texttt{b} $\triangleright~0.0$.

\section{Code Optimisation}
There are two types of optimalisation implemented, we calculate as much constant values at compile time as posible an we unroll forloops where posible.
\subsection{Constant Calculating}
To save time at runtime some calculations can be made at compiletime, for example:
\[
(3+4)*x \Rightarrow 7*x
\]
We implemented a very minimal optimalisation that only does something in simple cases.
It wont reconize cases like:
\[
3+x+4
\]
Or even, due to the tree structure:
\[
x+3+4 = (x+3)+4
\]
It will only alter branches of an expression without variables or function calls in it.
\subsection{Loop unrolling}
As with the above optimalisation, we use that some values are known at compiletime to save some work at runtime.
If the range of a forloop is known and small enough we can output the body of the loop for each value instead of jumping back and fort.
The range has to bo small enough, we define this as five or below, so the size of the bytecode does not exploid.


\section{Code Preparation}
\subsection{Variable Counting}
In this phase, the external functions are assigned their ``import position'', and global variables get a ``global position''. Then, each function's parameters and local variables are given a ``scope position'', and the function notes its number of local variables. 

For loops increase the number of local variables either by 1 or by 3, reserving space to store the \emph{to} and, if specified, the \emph{incr} field. If the \emph{incr} field is present, the third space is used to store wether or not the for loop is decreasing or increasing.
\subsection{Nested Function Renaming}
Nested functions are renamed in the style \texttt{foo.bar}, where \texttt{foo} is a function containing a function \texttt{bar}. This way, no conflicts arise with user defined functions \texttt{foo\_bar}.

\section{Code Generation}
The codegeneration is one of the main aspects of the compiler and there is a lot of administration involved.
For a start, we have to keep track of the generated code.
We use a linked list asambley lines and a lot of helperfunctions to make the managment easier.

Then there is the problem of constants, they have to be listed at the end of the code.
This brings the problem that we dont want to list the same constant twice, so we have to keep a list of already used constants.
This list contains both ints and floats so we had to use a union.
 
Then, for the actual code generation; the simplest cases are the integer and floatingpoint expressions.
This is due to the stack based nature of the VM. To do $A+B$ where $A$ and $B$ are more complex expressions, we simply take the assembly of $A$, this will leave the result on the stack when executed, then te assembly of $B$ and and with a simple "iadd".

Bolean expressions formt a bigger problem since most had no implementation in the VM. However, this could always be solvedwith a few more lines of assembly.

All ather strucures in the AST are also strait forward, it is mostly the assembly of the children wraped in a few lines of extra assembly.
\end{document}
