\documentclass[a4paper,11pt]{report}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{lmodern}

\title{Compiler Construction}
\author{Sander in 't Veld \and Joran van Apeldoorn}

\begin{document}

\maketitle
\tableofcontents

%\begin{abstract}
%\end{abstract}

\chapter{Compiler Phases}
The first three phases, `Loading', `Context Analysis' and `Type Checking', interpret the code and build the full abstract syntax tree. The next three phases restructure, optimise and prepare the AST, before the last phase, `Code Generation'. ZINNEN ZIJN LASTIG.

\section{Loading the code}
\subsection{Running the preprocessor}
Our compiler runs the \texttt{CPP} preprocessor and saves the resulting code in a hidden file called `\texttt{dir/.code.cvc.cpp}', if the original code was called `\texttt{dir/code.cvc}'. This step removes single- and multi-line comments, while retaining line and column numbers. It also links header files. The flag \texttt{-I path} can be used to search for header files in the directory \texttt{path}.

The resulting code is used as input for the next phase.

\subsection{Scanning}
Our scanner interprets the \texttt{\#line} preprocessor hints to provide accurate error messages during scanning and parsing.

The scanner accepts \texttt{CR}, \texttt{LF}, \texttt{CR LF} and \texttt{LF CR} as a valid line ending.

Integers between $-2^{31}$ and $2^{31}-1$ (inclusive) are always supported; larger integers may be supported, depending on the platform. Floats have similar ranges of support. The scanner accepts both \texttt{.5} and \texttt{2.} as shorthand notation for \texttt{0.5} and \texttt{2.0} respectively.

\subsection{Parsing}

\section{Context Analysis}
Namelinking happens before declaration splitting.
\subsection{Namelinking}
\subsection{Declaration splitting}

\section{Type Checking}
\subsection{Type Inference}
\subsection{Type Matching}

\section{Code Restructuring}
\subsection{Iterator Splitting}
\subsection{Array Splitting}
\subsection{Getters and Setters}
\subsection{Ternary Operators}

\section{Code Optimisation}
There are two types of optimalisation implemented, we calculate as much constant values at compile time as posible an we unroll forloops where posible.
\subsection{Constant Calculating}
To save time at runtime some calculations can be made at compiletime, for example:
\[
(3+4)*x \Rigtharrow 7*x
\]
We implemented a very minimal optimalisation that only does something in simple cases.
It wont reconize cases like:
\[
3+x+4
\]
Or even, due to the tree structure:
\[
x+3+4 = (x+3)+4
\]
It will only alter branches of an expression without variables or function calls in it.
\subsection{Loop unrolling}
As with the above optimalisation, we use that some values are known at compiletime to save some work at runtime.
If the range of a forloop is known and small enough we can output the body of the loop for each value instead of jumping back and fort.
The range has to bo small enough, we define this as five or below, so the size of the bytecode does not exploid.


\section{Code Preparation}
\subsection{Variable Counting}
\subsection{Nested Function Renaming}

\section{Code Generation}
The codegeneration is one of the main aspects of the compiler and there is a lot of administration involved.
For a start, we have to keep track of the generated code.
We use a linked list asambley lines and a lot of helperfunctions to make the managment easier.

Then there is the problem of constants, they have to be listed at the end of the code.
This brings the problem that we dont want to list the same constant twice, so we have to keep a list of already used constants.
This list contains both ints and floats so we had to use a union.
 
Then, for the actual code generation; the simplest cases are the integer and floatingpoint expressions.
This is due to the stack based nature of the VM. To do $A+B$ where $A$ and $B$ are more complex expressions, we simply take the assembly of $A$, this will leave the result on the stack when executed, then te assembly of $B$ and and with a simple "iadd".

Bolean expressions formt a bigger problem since most had no implementation in the VM. However, this could always be solvedwith a few more lines of assembly.

All ather strucures in the AST are also strait forward, it is mostly the assembly of the children wraped in a few lines of extra assembly.
\end{document}
